<#
// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.

using System;
using System.Numerics;
using System.Runtime.CompilerServices;

// <auto-generated />
<#
char[] coordz = {'X', 'Y', 'Z', 'W'};
#>
namespace FreePPlus.Imaging.Formats.Jpeg.Components
{
	internal partial struct Block8x8F
    {
		/// <summary>
        /// Transpose the block into the destination block.
        /// </summary>
        /// <param name="d">The destination block</param>
		[MethodImpl(InliningOptions.ShortMethod)]
        public void TransposeInto(ref Block8x8F d)
        {
            <#
			PushIndent("            ");

            for (int i = 0; i < 8; i++)
            {
                char destCoord = coordz[i % 4];
                char destSide = (i / 4) % 2 == 0 ? 'L' : 'R';

                for (int j = 0; j < 8; j++)
                {
					if(i > 0 && j == 0){
					WriteLine("");
					}

                    char srcCoord = coordz[j % 4];
                    char srcSide = (j / 4) % 2 == 0 ? 'L' : 'R';

                    var expression = $"d.V{j}{destSide}.{destCoord} = V{i}{srcSide}.{srcCoord};\r\n";
					Write(expression);
                }
            }
			PopIndent();
			#>
        }

		/// <summary>
        /// Level shift by +maximum/2, clip to [0, maximum]
        /// </summary>
        public void NormalizeColorsInplace(float maximum)
        {
            var CMin4 = new Vector4(0F);
            var CMax4 = new Vector4(maximum);
            var COff4 = new Vector4(MathF.Ceiling(maximum / 2));

            <#

			PushIndent("            ");

            for (int i = 0; i < 8; i++)
            {
                for (int j = 0; j < 2; j++)
                {
					char side = j == 0 ? 'L' : 'R';
					Write($"this.V{i}{side} = Vector4Utilities.FastClamp(this.V{i}{side} + COff4, CMin4, CMax4);\r\n");
                }
            }
			PopIndent();
			#>
        }

        /// <summary>
        /// AVX2-only variant for executing <see cref="NormalizeColorsInplace"/> and <see cref="RoundInplace"/> in one step.
        /// </summary>
        [MethodImpl(InliningOptions.ShortMethod)]
        public void NormalizeColorsAndRoundInplaceVector8(float maximum)
        {
            var off = new Vector<float>(MathF.Ceiling(maximum / 2));
            var max = new Vector<float>(maximum);
            <#

            for (int i = 0; i < 8; i++)
            {
                #>

            ref Vector<float> row<#=i#> = ref Unsafe.As<Vector4, Vector<float>>(ref this.V<#=i#>L);
            row<#=i#> = NormalizeAndRound(row<#=i#>, off, max);
                <#
            }
			#>

        }

        /// <summary>
        /// Fill the block from 'source' doing short -> float conversion.
        /// </summary>
        public void LoadFromInt16Scalar(ref Block8x8 source)
        {
            ref short selfRef = ref Unsafe.As<Block8x8, short>(ref source);

            <#
			PushIndent("            ");
            for (int j = 0; j < 8; j++)
            {
                for (int i = 0; i < 8; i++)
                {
                    char destCoord = coordz[i % 4];
                    char destSide = (i / 4) % 2 == 0 ? 'L' : 'R';

					if(j > 0 && i == 0){
					WriteLine("");
					}

                    char srcCoord = coordz[j % 4];
                    char srcSide = (j / 4) % 2 == 0 ? 'L' : 'R';

                    var expression = $"this.V{j}{destSide}.{destCoord} =  Unsafe.Add(ref selfRef, {j*8+i});\r\n";
					Write(expression);

                }
            }
			PopIndent();
			#>
        }
	}
}
